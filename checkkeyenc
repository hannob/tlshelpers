#!/usr/bin/python3
# SPDX-License-Identifier: 0BSD
#
# Checks if ECDSA private d length is correct.
# Context:
# https://seclists.org/oss-sec/2025/q4/38
# https://seclists.org/oss-sec/2025/q4/41
#
# Test with examples/ecdsa-dzero-{correct,bad}.key

import argparse
import base64
import math
import pathlib
import re
import sys

import cryptography
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives.serialization import load_der_private_key, load_pem_private_key
from pyasn1.codec.der.decoder import decode

p_re = re.compile(b"-----BEGIN[A-Z ]* PRIVATE KEY-----\n(.*)\n-----END[A-Z ]* PRIVATE KEY-----",
                  flags=re.MULTILINE | re.DOTALL)

ap = argparse.ArgumentParser()
ap.add_argument("keyfiles", nargs="+")
args = ap.parse_args()

for kf in args.keyfiles:
    kdata = pathlib.Path(kf).read_bytes()

    try:
        if b"PRIVATE KEY-----" in kdata:
            pem = True
            priv = load_pem_private_key(kdata, password=None)
        else:
            pem = False
            priv = load_der_private_key(kdata, password=None)
    except (ValueError, TypeError, cryptography.exceptions.UnsupportedAlgorithm):
        print(f"{kf}: Cannot load key")
        continue

    if not isinstance(priv, ec.EllipticCurvePrivateKey):
        print(f"{kf}: Not an ECDSA key")
        continue

    expectedbytes = math.ceil(priv.key_size / 8)

    if pem:
        pmatch = p_re.search(kdata)
        kdata = base64.b64decode(pmatch[1])

    d = decode(kdata)

    if d[0][0] == 0:
        # PKCS #8
        d1 = decode(d[0][2])
        priv_d = d1[0][1]
    elif d[0][0] == 1:
        # "traditional" format
        priv_d = d[0][1]
    else:
        sys.exit(f"Error processing key {kf}")

    if len(priv_d) != expectedbytes:
        print(f"ERROR: {kf} expected {expectedbytes} bytes, got {len(priv_d)} for private d")
    elif priv_d[0] == 0:
        print(f"INFO: {kf} private d starts with zero byte, but is encoded correctly")
    else:
        print(f"INFO: {kf} private d does not start with zero byte")
